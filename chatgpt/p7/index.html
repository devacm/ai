<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2048 Puzzle Game - One-Cell Drag Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- CSS for the game -->
  <style>
    /* Reset and Base Styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f0f0f0;
      color: #333;
      overflow-x: hidden;
    }
    h1, h2, h3 {
      margin-bottom: 10px;
      text-align: center;
    }
    button {
      cursor: pointer;
      padding: 10px 20px;
      margin: 10px;
      border: none;
      border-radius: 5px;
      background: #4caf50;
      color: #fff;
      font-size: 1em;
      transition: background 0.3s;
    }
    button:hover {
      background: #43a047;
    }
    
    /* Menu Screen */
    #menu {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background: radial-gradient(circle, #d9e4f5, #8fa7d6);
      animation: bgParticles 10s infinite alternate;
    }
    @keyframes bgParticles {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }
    #menu .menu-buttons {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    /* Game Container */
    #game-container {
      display: none;
      padding: 20px;
      min-height: 100vh;
      background: #eaeaea;
      position: relative;
    }
    #header {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }
    #score-board {
      display: flex;
      gap: 20px;
      font-size: 1.2em;
      font-weight: bold;
    }
    #controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    /* Game Board (Grid) */
    #game-board {
      position: relative;
      width: 90vw;
      max-width: 500px;
      margin: 0 auto;
      background: #bbada0;
      border-radius: 10px;
      padding: 10px;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-gap: 10px;
    }
    /* Each cell in the grid */
    .cell {
      background: rgba(238, 228, 218, 0.35);
      border-radius: 5px;
      position: relative;
      width: 100%;
      padding-bottom: 100%; /* maintain square shape */
      overflow: hidden;
    }
    /* Draggable/Swipable tile inside a cell */
    .tile-inner {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      font-weight: bold;
      border-radius: 5px;
      transition: transform 0.2s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
    }
    /* Example color scheme for numbered tiles */
    .tile-2   { background: #eee4da; color: #776e65; }
    .tile-4   { background: #ede0c8; color: #776e65; }
    .tile-8   { background: #f2b179; color: #f9f6f2; }
    .tile-16  { background: #f59563; color: #f9f6f2; }
    .tile-32  { background: #f67c5f; color: #f9f6f2; }
    .tile-64  { background: #f65e3b; color: #f9f6f2; }
    .tile-128 { background: #edcf72; color: #f9f6f2; }
    .tile-256 { background: #edcc61; color: #f9f6f2; }
    .tile-512 { background: #edc850; color: #f9f6f2; }
    .tile-1024 { background: #edc53f; color: #f9f6f2; }
    .tile-2048 { background: #edc22e; color: #f9f6f2; }
    
    /* Highlight effect on active tile */
    .active-tile {
      outline: 3px dashed #555;
    }
    
    /* Popup Overlay for Game Over and Win */
    #popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    #popup {
      background: #fff;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      width: 80%;
      max-width: 400px;
    }
    
    /* Instructions Modal */
    #instructions-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 150;
    }
    #instructions-modal .instructions-content {
      background: #fff;
      padding: 20px 30px;
      border-radius: 10px;
      text-align: center;
      max-width: 400px;
      width: 90%;
    }
    #instructions-modal h2 {
      margin-bottom: 15px;
    }
    #instructions-modal p {
      margin-bottom: 20px;
    }
    #instructions-modal .instructions-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    
    /* Settings Panel */
    #settings-panel {
      display: none;
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: #fff;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      z-index: 200;
    }
    #settings-panel h2 {
      margin-bottom: 10px;
    }
    #settings-panel label {
      display: block;
      margin-bottom: 10px;
    }
    #settings-panel input[type="checkbox"],
    #settings-panel select {
      margin-left: 10px;
    }
    
    /* Responsive */
    @media (max-width: 600px) {
      #game-board {
        width: 95vw;
      }
    }
  </style>
</head>
<body>
  <!-- Main Menu -->
  <div id="menu">
    <h1>2048 Puzzle Game</h1>
    <div class="menu-buttons">
      <button id="startGameBtn">Start Game</button>
      <button id="settingsBtn">Settings</button>
      <button id="howToPlayBtn">How to Play</button>
      <button id="leaderboardBtn">Leaderboard</button>
      <button id="aboutBtn">About</button>
    </div>
  </div>

  <!-- Instructions Modal (shown to new users) -->
  <div id="instructions-modal">
    <div class="instructions-content">
      <h2 id="instruction-title">How to Play</h2>
      <p id="instruction-text"></p>
      <div class="instructions-buttons">
        <button id="prevBtn" style="display: none;">Previous</button>
        <button id="nextBtn">Next</button>
        <button id="closeInstructionsBtn" style="display: none;">Got it!</button>
      </div>
    </div>
  </div>

  <!-- Settings Panel -->
  <div id="settings-panel">
    <h2>Settings</h2>
    <label>
      Theme:
      <select id="themeSelect">
        <option value="light">Light Mode</option>
        <option value="dark">Dark Mode</option>
      </select>
    </label>
    <label>
      Sound:
      <input type="checkbox" id="soundToggle" checked>
    </label>
    <button id="closeSettingsBtn">Close</button>
  </div>

  <!-- Game Container -->
  <div id="game-container">
    <div id="header">
      <div id="score-board">
        <div id="score">Score: 0</div>
        <div id="bestScore">Best: 0</div>
      </div>
      <div id="controls">
        <button id="undoBtn">Undo</button>
        <button id="pauseBtn">Pause</button>
        <button id="menuBtn">Menu</button>
      </div>
    </div>
    <div id="game-board"></div>
  </div>

  <!-- Popup Overlay for Game Over -->
  <div id="popup-overlay">
    <div id="popup">
      <h2 id="popup-title">Game Over</h2>
      <p id="popup-message">Your final score is <span id="finalScore">0</span></p>
      <button id="restartBtn">Restart</button>
      <button id="closePopupBtn">Close</button>
    </div>
  </div>

  <!-- Audio Elements -->
  <audio id="bg-music" loop>
    <source src="https://www.bensound.com/bensound-music/bensound-sunny.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="move-sound">
    <source src="https://www.soundjay.com/button/beep-07.mp3" type="audio/mpeg">
  </audio>
  <audio id="merge-sound">
    <source src="https://www.soundjay.com/button/sounds/button-29.mp3" type="audio/mpeg">
  </audio>
  <audio id="gameover-sound">
    <source src="https://www.soundjay.com/misc/sounds/fail-buzzer-01.mp3" type="audio/mpeg">
  </audio>

  <!-- JavaScript for the game and instructions -->
  <script>
    /* ============ Global Variables ============ */
    const BOARD_SIZE = 4;
    let board = [];
    let score = 0;
    let bestScore = 0;
    let previousState = null;  // for undo
    let gamePaused = false;
    let gameOver = false;

    /* For touch/mouse gesture handling */
    let activeTile = null; // element reference of the tile being moved
    let startX = 0, startY = 0;
    let fromI = null, fromJ = null; // starting cell indices

    /* Instruction steps (customize as needed) */
    const instructions = [
      "Welcome to 2048 Puzzle Game! In this game, you'll slide numbered tiles to combine them and reach the 2048 tile.",
      "To play, drag or swipe a tile in one of the four directions. The tile will move exactly one cell in that direction.",
      "If the adjacent cell is empty, your tile will move there. If it contains a tile with the same number, they will merge to form a tile with double the number.",
      "Your score increases with each merge. Try to reach the 2048 tile or even higher for a better score!",
      "Good luck and have fun playing the game!"
    ];
    let instructionIndex = 0;

    /* ============ DOM Elements ============ */
    const menu = document.getElementById('menu');
    const gameContainer = document.getElementById('game-container');
    const gameBoard = document.getElementById('game-board');
    const scoreDisplay = document.getElementById('score');
    const bestScoreDisplay = document.getElementById('bestScore');
    const popupOverlay = document.getElementById('popup-overlay');
    const popupTitle = document.getElementById('popup-title');
    const popupMessage = document.getElementById('popup-message');
    const finalScoreDisplay = document.getElementById('finalScore');
    const bgMusic = document.getElementById('bg-music');
    const moveSound = document.getElementById('move-sound');
    const mergeSound = document.getElementById('merge-sound');
    const gameoverSound = document.getElementById('gameover-sound');
    const settingsPanel = document.getElementById('settings-panel');
    const themeSelect = document.getElementById('themeSelect');
    const soundToggle = document.getElementById('soundToggle');
    // Instructions Modal Elements
    const instructionsModal = document.getElementById('instructions-modal');
    const instructionTitle = document.getElementById('instruction-title');
    const instructionText = document.getElementById('instruction-text');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const closeInstructionsBtn = document.getElementById('closeInstructionsBtn');

    /* ============ Local Storage Helpers ============ */
    // Load best score and settings from localStorage.
    function loadLocalStorage() {
      bestScore = parseInt(localStorage.getItem("bestScore")) || 0;
      bestScoreDisplay.innerText = `Best: ${bestScore}`;
      const savedTheme = localStorage.getItem("theme");
      if (savedTheme) {
        themeSelect.value = savedTheme;
        document.body.className = savedTheme;
      }
      const soundEnabled = localStorage.getItem("soundEnabled");
      if (soundEnabled !== null) {
        soundToggle.checked = (soundEnabled === "true");
        bgMusic.muted = !soundToggle.checked;
        moveSound.muted = !soundToggle.checked;
        mergeSound.muted = !soundToggle.checked;
        gameoverSound.muted = !soundToggle.checked;
      }
    }
    // Save best score and settings to localStorage.
    function saveBestScore() {
      localStorage.setItem("bestScore", bestScore);
    }
    function saveSettings() {
      localStorage.setItem("theme", themeSelect.value);
      localStorage.setItem("soundEnabled", soundToggle.checked);
    }
    // Save that instructions have been shown.
    function markInstructionsShown() {
      localStorage.setItem("instructionsShown", "true");
    }

    /* ============ Instructions Modal Logic ============ */
    function showInstructionStep() {
      instructionTitle.innerText = "How to Play";
      instructionText.innerText = instructions[instructionIndex];
      // Hide the "Previous" button on the first step.
      prevBtn.style.display = (instructionIndex === 0) ? "none" : "inline-block";
      // Change "Next" button to "Got it!" on the final step.
      if (instructionIndex === instructions.length - 1) {
        nextBtn.style.display = "none";
        closeInstructionsBtn.style.display = "inline-block";
      } else {
        nextBtn.style.display = "inline-block";
        closeInstructionsBtn.style.display = "none";
      }
    }
    function openInstructions() {
      instructionIndex = 0;
      showInstructionStep();
      instructionsModal.style.display = "flex";
    }
    function closeInstructions() {
      instructionsModal.style.display = "none";
      markInstructionsShown();
    }
    prevBtn.addEventListener('click', () => {
      if (instructionIndex > 0) {
        instructionIndex--;
        showInstructionStep();
      }
    });
    nextBtn.addEventListener('click', () => {
      if (instructionIndex < instructions.length - 1) {
        instructionIndex++;
        showInstructionStep();
      }
    });
    closeInstructionsBtn.addEventListener('click', closeInstructions);

    /* ============ Menu and Settings Events ============ */
    document.getElementById('startGameBtn').addEventListener('click', startGame);
    document.getElementById('menuBtn').addEventListener('click', returnToMenu);
    document.getElementById('restartBtn').addEventListener('click', restartGame);
    document.getElementById('closePopupBtn').addEventListener('click', closePopup);
    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    document.getElementById('undoBtn').addEventListener('click', undoMove);
    document.getElementById('settingsBtn').addEventListener('click', () => {
      settingsPanel.style.display = 'block';
    });
    document.getElementById('closeSettingsBtn').addEventListener('click', () => {
      settingsPanel.style.display = 'none';
      saveSettings();
    });
    document.getElementById('howToPlayBtn').addEventListener('click', () => {
      openInstructions();
    });
    document.getElementById('leaderboardBtn').addEventListener('click', () => {
      alert("Leaderboard feature coming soon!");
    });
    document.getElementById('aboutBtn').addEventListener('click', () => {
      alert("2048 Puzzle Game - One-Cell Drag Edition");
    });
    // Theme change event
    themeSelect.addEventListener('change', function() {
      document.body.className = this.value;
      saveSettings();
    });
    // Sound toggle event
    soundToggle.addEventListener('change', function() {
      bgMusic.muted = !this.checked;
      moveSound.muted = !this.checked;
      mergeSound.muted = !this.checked;
      gameoverSound.muted = !this.checked;
      saveSettings();
    });

    /* ============ Game Initialization ============ */
    function startGame() {
      menu.style.display = 'none';
      gameContainer.style.display = 'block';
      resetBoard();
      updateBoard();
      score = 0;
      updateScore();
      gameOver = false;
      gamePaused = false;
      bgMusic.play();
    }
    function returnToMenu() {
      gameContainer.style.display = 'none';
      menu.style.display = 'flex';
      bgMusic.pause();
    }
    function restartGame() {
      closePopup();
      startGame();
    }
    function resetBoard() {
      board = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        board[i] = [];
        for (let j = 0; j < BOARD_SIZE; j++) {
          board[i][j] = 0;
        }
      }
      // Add two starting tiles
      addRandomTile();
      addRandomTile();
    }

    /* ============ Board Updates and Rendering ============ */
    function updateBoard() {
      gameBoard.innerHTML = '';
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.setAttribute('data-i', i);
          cell.setAttribute('data-j', j);
          const value = board[i][j];
          if (value) {
            const tile = document.createElement('div');
            tile.classList.add('tile-inner', `tile-${value}`);
            tile.innerText = value;
            // Prevent default dragging
            tile.ondragstart = () => false;
            // Attach mouse and touch events to detect a swipe/drag gesture
            tile.addEventListener('mousedown', gestureStart);
            tile.addEventListener('touchstart', gestureStart, {passive: true});
            cell.appendChild(tile);
          }
          gameBoard.appendChild(cell);
        }
      }
    }
    function updateScore() {
      scoreDisplay.innerText = `Score: ${score}`;
      if (score > bestScore) {
        bestScore = score;
        bestScoreDisplay.innerText = `Best: ${bestScore}`;
        saveBestScore();
      }
    }

    /* ============ Gesture Handling ============ */
    function gestureStart(e) {
      if (gamePaused || gameOver) return;
      activeTile = e.currentTarget;
      const parent = activeTile.parentElement;
      fromI = parseInt(parent.getAttribute('data-i'));
      fromJ = parseInt(parent.getAttribute('data-j'));
      if (e.type === "mousedown") {
        startX = e.clientX;
        startY = e.clientY;
        document.addEventListener('mouseup', gestureEnd);
      } else if (e.type === "touchstart") {
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        document.addEventListener('touchend', gestureEnd, {passive: true});
      }
      activeTile.classList.add('active-tile');
    }
    function gestureEnd(e) {
      let endX, endY;
      if (e.type === "mouseup") {
        endX = e.clientX;
        endY = e.clientY;
        document.removeEventListener('mouseup', gestureEnd);
      } else if (e.type === "touchend") {
        const touch = e.changedTouches[0];
        endX = touch.clientX;
        endY = touch.clientY;
        document.removeEventListener('touchend', gestureEnd);
      }
      const diffX = endX - startX;
      const diffY = endY - startY;
      let direction = null;
      const threshold = 20;
      if (Math.abs(diffX) < threshold && Math.abs(diffY) < threshold) {
        activeTile && activeTile.classList.remove('active-tile');
        activeTile = null;
        return;
      }
      if (Math.abs(diffX) > Math.abs(diffY)) {
        direction = diffX > 0 ? 'right' : 'left';
      } else {
        direction = diffY > 0 ? 'down' : 'up';
      }
      activeTile && activeTile.classList.remove('active-tile');
      activeTile = null;
      attemptMove(fromI, fromJ, direction);
    }

    /* ============ Movement and Merging ============ */
    function attemptMove(fromI, fromJ, direction) {
      previousState = { board: JSON.parse(JSON.stringify(board)), score };
      let toI = fromI, toJ = fromJ;
      switch(direction) {
        case 'left': toJ = fromJ - 1; break;
        case 'right': toJ = fromJ + 1; break;
        case 'up': toI = fromI - 1; break;
        case 'down': toI = fromI + 1; break;
      }
      if (toI < 0 || toI >= BOARD_SIZE || toJ < 0 || toJ >= BOARD_SIZE) return;
      const value = board[fromI][fromJ];
      const targetValue = board[toI][toJ];
      if (targetValue === 0) {
        board[toI][toJ] = value;
        board[fromI][fromJ] = 0;
        moveSound.play();
      } else if (targetValue === value) {
        board[toI][toJ] = value * 2;
        board[fromI][fromJ] = 0;
        score += value * 2;
        mergeSound.play();
      } else {
        return;
      }
      updateBoard();
      updateScore();
      addRandomTile();
      updateBoard();
      updateScore();
      if (checkGameOver()) {
        endGame();
      }
    }

    /* ============ Tile Functions ============ */
    function addRandomTile() {
      const emptyTiles = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === 0) emptyTiles.push({ i, j });
        }
      }
      if (emptyTiles.length > 0) {
        const { i, j } = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
        board[i][j] = Math.random() < 0.9 ? 2 : 4;
      }
    }

    /* ============ Game Over and Pause ============ */
    function checkGameOver() {
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === 0) return false;
        }
      }
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (i < BOARD_SIZE - 1 && board[i][j] === board[i+1][j]) return false;
          if (j < BOARD_SIZE - 1 && board[i][j] === board[i][j+1]) return false;
        }
      }
      return true;
    }
    function endGame() {
      gameOver = true;
      gameoverSound.play();
      finalScoreDisplay.innerText = score;
      popupTitle.innerText = "Game Over";
      popupMessage.innerHTML = `Your final score is <span id="finalScore">${score}</span>`;
      popupOverlay.style.display = 'flex';
    }
    function closePopup() {
      popupOverlay.style.display = 'none';
    }
    function togglePause() {
      gamePaused = !gamePaused;
      if (gamePaused) {
        bgMusic.pause();
        document.getElementById('pauseBtn').innerText = "Resume";
      } else {
        bgMusic.play();
        document.getElementById('pauseBtn').innerText = "Pause";
      }
    }
    function undoMove() {
      if (previousState) {
        board = JSON.parse(JSON.stringify(previousState.board));
        score = previousState.score;
        updateBoard();
        updateScore();
        previousState = null;
      }
    }

    // When the page loads, load settings, best score, and show instructions if needed.
    window.onload = function() {
      loadLocalStorage();
      // Check if instructions have been shown before.
      if (!localStorage.getItem("instructionsShown")) {
        openInstructions();
      }
    }
  </script>
   <div style="width: 90%; text-align: center; margin: auto;">
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <h2>Used Prompt to generate this site:</h2><br>
    <p>2048 Puzzle Game: A Modern Web Experience
        The 2048 Puzzle Game is a popular single-player sliding tile game where players combine numbered tiles on a 4x4 grid to create a tile with the number 2048. Below is a detailed description of the game, its working, and all the features that can be implemented to deliver a modern, engaging experience.
        
        Game Objective
        The player’s goal is to slide numbered tiles on the grid, combining them into higher values by matching tiles of the same number. The ultimate aim is to reach the 2048 tile, but the game doesn’t end there. Players can continue playing to achieve even higher scores.
        
        Core Gameplay
        Grid Layout:
        
        A 4x4 grid serves as the playing area.
        At the start of the game, two tiles (either 2 or 4) appear randomly.
        Tile Movement:
        
        Tiles can be moved in four directions: up, down, left, and right.
        When two tiles of the same number collide during a move, they merge into a new tile with the sum of their values (e.g., 2 + 2 = 4).
        Game Over:
        
        The game ends when there are no valid moves left (i.e., the grid is full and no tiles can merge).
        Scoring:
        
        Every time tiles merge, the value of the new tile is added to the player’s score.
        The score keeps updating dynamically.
        Modern Features to Include
        1. Home Screen (Menu)
        A polished menu screen with options like:
        Start Game
        Settings
        How to Play
        Leaderboard
        About
        Include a background animation like floating particles or subtle geometric patterns to create a modern feel.
        2. Game Design
        Use a sleek and minimalist design with smooth gradients and subtle shadows.
        Tiles should have rounded corners, vibrant colors, and animations when merging or appearing.
        The grid should appear dynamic, with glowing edges or a textured background.
        3. Animations
        Tiles should slide smoothly across the grid with a bounce effect upon merging.
        Add animations for:
        New tiles appearing (e.g., scaling in from 0 to full size).
        Merged tiles glowing briefly to highlight the action.
        4. Settings
        Options for:
        Theme Selection: Light mode, dark mode, or custom themes with various color palettes.
        Sound Control: Enable/disable background music and sound effects.
        Tile Appearance: Allow players to choose between numbered tiles or icons for a personalized look.
        5. Music and Sound Effects
        Background music: A calming or engaging tune that keeps the player immersed.
        Sound effects for:
        Tile movement.
        Tile merging.
        Game over.
        6. Responsiveness
        The game should be fully responsive, playable on devices of all screen sizes, including desktops, tablets, and smartphones.
        7. Leaderboard
        A global leaderboard where players can upload their scores.
        Track statistics like:
        High score.
        Total games played.
        Average score.
        Include a nickname feature to personalize the leaderboard.
        8. Game Modes
        Classic Mode: The standard 2048 gameplay.
        Timed Mode: The player has a limited time to score as much as possible.
        Challenge Mode: Customizable grid sizes (e.g., 3x3, 5x5) or additional obstacles.
        9. Visual Effects
        Subtle effects like glowing tiles, particle bursts when tiles merge, and grid shake when no moves are possible.
        Use CSS transitions for smooth, modern animations.
        10. Pause and Resume
        Allow players to pause the game and resume later.
        Save the current game state locally so players can pick up where they left off.
        11. Undo Feature
        Offer a one-step undo button to let players correct mistakes.
        12. Accessibility
        Keyboard controls (W, A, S, D or arrow keys).
        Swipe gestures for mobile devices.
        Visual hints for possible moves to assist beginners.
        Technical Implementation
        Frontend Technologies
        HTML: To structure the grid, menu, and settings layout.
        CSS: For responsive design, animations, and modern visual appeal.
        JavaScript: To handle game logic, tile movement, merging, scoring, and event handling.
        Backend (Optional)
        Use a backend (Node.js or Firebase) for features like leaderboards, user profiles, and saving game progress.
        Web Game Workflow
        Initialization:
        
        The grid initializes with two random tiles (2 or 4).
        The score is set to 0.
        User Input:
        
        Players can move tiles using arrow keys, W/A/S/D, or swipe gestures.
        Input triggers JavaScript functions to calculate tile movement.
        Tile Movement:
        
        Tiles slide in the chosen direction until they collide with another tile or the edge.
        If two tiles of the same value collide, they merge, forming a new tile.
        New Tile Generation:
        
        After each move, a new tile (2 or 4) appears randomly on an empty space.
        Game Over Check:
        
        After each move, check if no valid moves are available.
        If so, display the game over screen with the final score and options to restart or return to the menu.
        Win Condition:
        
        If the player forms a 2048 tile, display a congratulatory message.
        Offer the option to continue playing.
        Conclusion
        A modern 2048 Puzzle Game should go beyond basic functionality to deliver a visually appealing, feature-rich, and user-friendly experience. By incorporating animations, themes, sound effects, and additional game modes, you can create a polished web game that feels engaging and contemporary. Let me know if you’d like further assistance with designing or coding this game! Give me the entire code at once. code should be coded using HTML,CSS, js ony.</p> <br><br>
        <p><strong>Next Prompt</strong></p>
        <p>working perfect but i want that user have to drag the number to other box for mix up the number. you coded a game where user only have to give gesture of left, right, top , bottom to play the game. but I want user to move each box for the number combination. You coded a game where user move left to right and all numbers get move. but I want other type of playing method. </p>
        <p><strong>Next Prompt</strong></p>
        <p>working good but i said that if there is a box then user can move it to the next 1 box only at once. user can not drag the box to 2-3 or more next box. and make the game playable in mobile too. means user can play game using mouse and touch screen to. if a user give gesture over a number box to left, right, top, or bottom. then box will move to the next 1 box only in the given direction of the gesture. </p>
        <p><strong>Next Prompt</strong></p>
        <p>make the game settings and its best score to be saved in browser side storage. and show the Best score when user is playing the game or opened the game website. </p>
        <p><strong>Next Prompt</strong></p>
        <p>add Instructions to play the game. if a new user come to the website then show them how to play step by step popups.</p>
    </div>
</body>
</html>
