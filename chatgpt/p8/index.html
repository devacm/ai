<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Full Rules Chess: Player vs. AI with Coordinates & Audio</title>
  <style>
    /* RESET & GLOBAL STYLES */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #3e3e3e;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    h1, h2 {
      text-shadow: 0 2px 4px rgba(0,0,0,0.6);
      margin-bottom: 10px;
    }
    button, select, input[type="checkbox"] {
      font-size: 16px;
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    button:hover {
      background: #555;
    }
    /* MAIN MENU */
    #main-menu {
      text-align: center;
      margin-top: 60px;
    }
    #main-menu button {
      margin: 10px 5px;
      background: #222;
      color: #fff;
    }
    /* BOARD CONTAINER (includes coordinates) */
    #boardContainer {
      position: relative;
      margin: 20px 0;
      display: inline-block;
    }
    /* TOP coordinate labels */
    #topLabels {
      display: grid;
      grid-template-columns: repeat(8, 80px);
      position: absolute;
      top: -30px;
      left: 40px; /* leave space for left labels */
    }
    #topLabels div {
      text-align: center;
      font-weight: bold;
    }
    /* LEFT coordinate labels */
    #leftLabels {
      display: grid;
      grid-template-rows: repeat(8, 80px);
      position: absolute;
      top: 0;
      left: -30px;
      text-align: center;
      font-weight: bold;
      line-height: 80px;
    }
    /* GAME CONTAINER & BOARD STYLES */
    #gameContainer {
      display: none;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 640px;
    }
    #gameInfo {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
    }
    #chessBoard {
      display: grid;
      grid-template-columns: repeat(8, 80px);
      grid-template-rows: repeat(8, 80px);
      border: 4px solid #555;
      box-shadow: 0 8px 16px rgba(0,0,0,0.8);
      position: relative;
    }
    .square {
      width: 80px;
      height: 80px;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background 0.3s ease, transform 0.3s ease;
      position: relative;
    }
    /* Wooden board colors: light and dark squares */
    .light { background: #f0d9b5; }
    .dark  { background: #b58863; }
    /* Highlight & selection */
    .selected { 
      outline: 4px solid #ffcc00;
      transform: scale(1.05);
      z-index: 2;
    }
    .highlight {
      outline: 4px solid #00cc66;
      transform: scale(1.05);
      z-index: 1;
    }
    /* Check highlight */
    .in-check {
      outline: 4px solid #ff3300 !important;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 5px #ff3300; }
      50% { box-shadow: 0 0 15px #ff3300; }
      100% { box-shadow: 0 0 5px #ff3300; }
    }
    /* Move Animation */
    .move-animation {
      animation: moveAnim 0.4s ease-out;
    }
    @keyframes moveAnim {
      0% { transform: translateY(-40px) scale(0.8); opacity: 0; }
      100% { transform: translateY(0) scale(1); opacity: 1; }
    }
    /* Chess Piece Images (modern style â€“ using external SVGs) */
    .piece img {
      width: 70px;
      height: 70px;
      user-select: none;
      pointer-events: none;
    }
    /* Captured Pieces Display */
    #capturedContainer {
      width: 100%;
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
    }
    .captured {
      border: 2px solid #555;
      padding: 10px;
      width: 48%;
      min-height: 60px;
      background: #2a2a2a;
      border-radius: 6px;
    }
    .captured h3 {
      margin-bottom: 5px;
      font-size: 16px;
      text-align: center;
    }
    .captured .piece {
      margin: 2px;
      display: inline-block;
    }
    /* Undo Button */
    #undoBtn {
      background: #990000;
      color: #fff;
      margin-right: 10px;
    }
    /* MODAL (for settings, messages, promotion) */
    .modal {
      display: none;
      position: fixed;
      z-index: 200;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.75);
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .modal-content {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 8px;
      width: 100%;
      max-width: 500px;
      position: relative;
      box-shadow: 0 8px 16px rgba(0,0,0,0.8);
      color: #fff;
      text-align: center;
    }
    .close {
      color: #aaa;
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.3s ease;
    }
    .close:hover { color: #fff; }
    .modal label {
      display: block;
      margin: 10px 0;
    }
    .modal select, .modal input[type="checkbox"] {
      margin-left: 10px;
    }
    .modal button {
      background: #444;
      color: #fff;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <!-- Background Music and Move Sound Audio Elements -->
  <audio id="bgMusic" loop>
    <source src="https://www.bensound.com/bensound-music/bensound-slowmotion.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="moveSound">
    <source src="https://www.soundjay.com/button/beep-07.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>

  <!-- Main Menu -->
  <div id="main-menu">
    <h1>Full Rules Chess: Player vs. AI with Smart Hints</h1>
    <button id="playNow">Play Now</button>
    <button id="settingsBtn">Settings</button>
    <button id="howToPlayBtn">How to Play</button>
    <a href="https://devacm.github.io/ai/chatgpt/p8/prompt.html" style="padding: 0.5rem 1rem; background-color: #202020; border-radius: 10px; text-decoration: none; color: white;" target="_blank" rel="noopener noreferrer">Get AI Prompt</a>
  </div>

  <!-- Game Container -->
  <div id="gameContainer">
    <div id="gameInfo">
      <span id="status">Turn: White</span>
      <div>
        <button id="undoBtn">Undo</button>
        <button id="hintBtn">Get Hint</button>
        <button id="backToMenu">Back to Menu</button>
      </div>
    </div>
    <!-- Board Container with Coordinate Labels -->
    <div id="boardContainer">
      <div id="topLabels">
        <div>A</div><div>B</div><div>C</div><div>D</div>
        <div>E</div><div>F</div><div>G</div><div>H</div>
      </div>
      <div id="leftLabels">
        <div>8</div><div>7</div><div>6</div><div>5</div>
        <div>4</div><div>3</div><div>2</div><div>1</div>
      </div>
      <div id="chessBoard"></div>
    </div>
    <div id="capturedContainer">
      <div class="captured" id="capturedByPlayer">
        <h3>Captured by You</h3>
      </div>
      <div class="captured" id="capturedByAI">
        <h3>Captured by AI</h3>
      </div>
    </div>
  </div>

  <!-- Modal (for settings, messages, promotion) -->
  <div id="modal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <div id="modalBody"></div>
    </div>
  </div>

  <script>
    /***********************************
     * GLOBAL VARIABLES & SETTINGS
     ***********************************/
    const boardElement = document.getElementById('chessBoard');
    const mainMenu = document.getElementById('main-menu');
    const gameContainer = document.getElementById('gameContainer');
    const statusElement = document.getElementById('status');
    const modal = document.getElementById('modal');
    const modalBody = document.getElementById('modalBody');
    const closeModal = document.querySelector('.close');
    const hintBtn = document.getElementById('hintBtn');
    const undoBtn = document.getElementById('undoBtn');
    const capturedByPlayerEl = document.getElementById('capturedByPlayer');
    const capturedByAIEl = document.getElementById('capturedByAI');
    const bgMusic = document.getElementById('bgMusic');
    const moveSound = document.getElementById('moveSound');

    // Settings variables for audio.
    let difficulty = "easy"; // For future use (AI strength)
    let showHints = true;
    let bgMusicMuted = false;
    let moveSoundMuted = false;

    /***********************************
     * GAME STATE VARIABLES
     ***********************************/
    let board = [];
    let castlingRights = {
      whiteKing: true, whiteQueen: true,
      blackKing: true, blackQueen: true
    };
    let enPassantTarget = null;
    let moveHistory = [];
    let capturedByPlayer = [];
    let capturedByAI = [];
    let currentTurn = 'white';
    let selectedSquare = null;

    const pieceImages = {
      'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
      'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
      'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
      'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
      'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
      'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg',
      'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg',
      'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
      'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
      'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
      'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
      'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg'
    };

    /***********************************
     * INITIALIZATION & BOARD RENDERING
     ***********************************/
    function initGame() {
      board = [
        ["r","n","b","q","k","b","n","r"],
        ["p","p","p","p","p","p","p","p"],
        ["","","","","","","",""],
        ["","","","","","","",""],
        ["","","","","","","",""],
        ["","","","","","","",""],
        ["P","P","P","P","P","P","P","P"],
        ["R","N","B","Q","K","B","N","R"]
      ];
      castlingRights = { whiteKing: true, whiteQueen: true, blackKing: true, blackQueen: true };
      enPassantTarget = null;
      moveHistory = [];
      capturedByPlayer = [];
      capturedByAI = [];
      currentTurn = 'white';
      selectedSquare = null;
      updateCapturedDisplay(capturedByPlayerEl, capturedByPlayer);
      updateCapturedDisplay(capturedByAIEl, capturedByAI);
      statusElement.textContent = "Turn: White";
      initBoard();
      if (!bgMusicMuted) bgMusic.play();
    }

    function initBoard() {
      boardElement.innerHTML = '';
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const square = document.createElement('div');
          square.classList.add('square');
          square.dataset.row = i;
          square.dataset.col = j;
          square.classList.add(((i + j) % 2 === 0) ? 'light' : 'dark');
          const piece = board[i][j];
          if (piece) {
            const pieceElement = document.createElement('div');
            pieceElement.classList.add('piece');
            const img = document.createElement('img');
            img.src = pieceImages[piece];
            img.alt = piece;
            pieceElement.appendChild(img);
            square.appendChild(pieceElement);
          }
          square.addEventListener('click', handleSquareClick);
          boardElement.appendChild(square);
        }
      }
      detectGameState();
    }

    /***********************************
     * MOVE GENERATION (INCLUDING SPECIAL MOVES)
     ***********************************/
    function getLegalMoves(row, col) {
      const piece = board[row][col];
      if (!piece) return [];
      let moves = [];
      const isWhite = (piece === piece.toUpperCase());
      const dir = isWhite ? -1 : 1;
      switch(piece.toUpperCase()){
        case 'P':
          if (inBounds(row + dir, col) && board[row + dir][col] === "") {
            moves.push({row: row + dir, col, promotion: (isWhite && row+dir===0) || (!isWhite && row+dir===7)});
            if ((isWhite && row === 6) || (!isWhite && row === 1)) {
              if (board[row + 2*dir][col] === "" && board[row + dir][col] === "")
                moves.push({row: row + 2*dir, col, enPassant: true});
            }
          }
          for (let dc of [-1, 1]) {
            if (inBounds(row+dir, col+dc)) {
              const target = board[row+dir][col+dc];
              if (target && isOpponentPiece(piece, target))
                moves.push({row: row+dir, col: col+dc, promotion: (isWhite && row+dir===0) || (!isWhite && row+dir===7)});
              if (!target && enPassantTarget && enPassantTarget.row === row+dir && enPassantTarget.col === col+dc)
                moves.push({row: row+dir, col: col+dc, enPassantCapture: true});
            }
          }
          break;
        case 'N':
          const knightMoves = [
            {r: -2, c: -1}, {r: -2, c: 1},
            {r: -1, c: -2}, {r: -1, c: 2},
            {r: 1, c: -2}, {r: 1, c: 2},
            {r: 2, c: -1}, {r: 2, c: 1}
          ];
          knightMoves.forEach(m => {
            const newRow = row + m.r, newCol = col + m.c;
            if (inBounds(newRow, newCol)) {
              const target = board[newRow][newCol];
              if (!target || isOpponentPiece(piece, target))
                moves.push({row: newRow, col: newCol});
            }
          });
          break;
        case 'B':
          moves.push(...generateSlidingMoves(row, col, piece, [[-1,-1],[-1,1],[1,-1],[1,1]]));
          break;
        case 'R':
          moves.push(...generateSlidingMoves(row, col, piece, [[-1,0],[1,0],[0,-1],[0,1]]));
          break;
        case 'Q':
          moves.push(...generateSlidingMoves(row, col, piece, [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]]));
          break;
        case 'K':
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr===0 && dc===0) continue;
              const newRow = row + dr, newCol = col + dc;
              if (inBounds(newRow, newCol)) {
                const target = board[newRow][newCol];
                if (!target || isOpponentPiece(piece, target))
                  moves.push({row: newRow, col: newCol});
              }
            }
          }
          moves.push(...generateCastlingMoves(row, col, piece));
          break;
      }
      return moves.filter(move => !leavesKingInCheck(row, col, move));
    }

    function generateSlidingMoves(row, col, piece, directions) {
      const moves = [];
      directions.forEach(dir => {
        let newRow = row + dir[0], newCol = col + dir[1];
        while (inBounds(newRow, newCol)) {
          const target = board[newRow][newCol];
          if (!target) {
            moves.push({row: newRow, col: newCol});
          } else {
            if (isOpponentPiece(piece, target))
              moves.push({row: newRow, col: newCol});
            break;
          }
          newRow += dir[0];
          newCol += dir[1];
        }
      });
      return moves;
    }

    function generateCastlingMoves(row, col, piece) {
      const moves = [];
      const isWhite = (piece === piece.toUpperCase());
      if (isWhite && row===7 && col===4) {
        if (castlingRights.whiteKing && board[7][5]==="" && board[7][6]==="") {
          if (!squareAttacked(7,4,'black') && !squareAttacked(7,5,'black') && !squareAttacked(7,6,'black'))
            moves.push({row: 7, col: 6, castling: 'king'});
        }
        if (castlingRights.whiteQueen && board[7][3]==="" && board[7][2]==="" && board[7][1]==="") {
          if (!squareAttacked(7,4,'black') && !squareAttacked(7,3,'black') && !squareAttacked(7,2,'black'))
            moves.push({row: 7, col: 2, castling: 'queen'});
        }
      } else if (!isWhite && row===0 && col===4) {
        if (castlingRights.blackKing && board[0][5]==="" && board[0][6]==="") {
          if (!squareAttacked(0,4,'white') && !squareAttacked(0,5,'white') && !squareAttacked(0,6,'white'))
            moves.push({row: 0, col: 6, castling: 'king'});
        }
        if (castlingRights.blackQueen && board[0][3]==="" && board[0][2]==="" && board[0][1]==="") {
          if (!squareAttacked(0,4,'white') && !squareAttacked(0,3,'white') && !squareAttacked(0,2,'white'))
            moves.push({row: 0, col: 2, castling: 'queen'});
        }
      }
      return moves;
    }

    function inBounds(row, col) {
      return row >= 0 && row < 8 && col >= 0 && col < 8;
    }
    function isOpponentPiece(piece, target) {
      return (piece === piece.toUpperCase() && target === target.toLowerCase()) ||
             (piece === piece.toLowerCase() && target === target.toUpperCase());
    }
    function squareAttacked(row, col, attackerColor) {
      for (let i=0; i<8; i++){
        for (let j=0; j<8; j++){
          const p = board[i][j];
          if (p && ((attackerColor==='white' && p===p.toUpperCase()) || (attackerColor==='black' && p===p.toLowerCase()))){
            const moves = getLegalMoves(i,j);
            if (moves.some(m => m.row===row && m.col===col))
              return true;
          }
        }
      }
      return false;
    }

    function leavesKingInCheck(fromRow, fromCol, move) {
      const boardCopy = board.map(r => r.slice());
      const savedEnPassant = enPassantTarget ? { ...enPassantTarget } : null;
      const savedCastling = { ...castlingRights };
      const movingPiece = boardCopy[fromRow][fromCol];
      boardCopy[move.row][move.col] = movingPiece;
      boardCopy[fromRow][fromCol] = "";
      if (move.enPassantCapture) {
        const capRow = movingPiece === movingPiece.toUpperCase() ? move.row+1 : move.row-1;
        boardCopy[capRow][move.col] = "";
      }
      if (move.castling) {
        if (move.castling==='king') {
          boardCopy[move.row][move.col-1] = boardCopy[move.row][7];
          boardCopy[move.row][7] = "";
        } else if (move.castling==='queen') {
          boardCopy[move.row][move.col+1] = boardCopy[move.row][0];
          boardCopy[move.row][0] = "";
        }
      }
      const king = (movingPiece === movingPiece.toUpperCase()) ? 'K' : 'k';
      let kingPos = null;
      for (let i=0; i<8; i++){
        for (let j=0; j<8; j++){
          if (boardCopy[i][j] === king) {
            kingPos = {row: i, col: j};
            break;
          }
        }
        if (kingPos) break;
      }
      if (!kingPos) return true;
      const opponent = (movingPiece === movingPiece.toUpperCase()) ? 'black' : 'white';
      for (let i=0; i<8; i++){
        for (let j=0; j<8; j++){
          const p = boardCopy[i][j];
          if (p && ((opponent==='white' && p===p.toUpperCase()) || (opponent==='black' && p===p.toLowerCase()))){
            const moves = getPseudoLegalMovesFromBoard(i,j, boardCopy);
            if (moves.some(m => m.row===kingPos.row && m.col===kingPos.col))
              return true;
          }
        }
      }
      enPassantTarget = savedEnPassant;
      castlingRights = savedCastling;
      return false;
    }

    function getPseudoLegalMovesFromBoard(row, col, boardState) {
      const piece = boardState[row][col];
      if (!piece) return [];
      let moves = [];
      const isWhite = (piece === piece.toUpperCase());
      const dir = isWhite ? -1 : 1;
      switch(piece.toUpperCase()){
        case 'P':
          if (inBounds(row+dir, col) && boardState[row+dir][col]==="") {
            moves.push({row: row+dir, col});
          }
          for (let dc of [-1,1]) {
            if (inBounds(row+dir, col+dc)) {
              const target = boardState[row+dir][col+dc];
              if (target && ((isWhite && target===target.toLowerCase()) || (!isWhite && target===target.toUpperCase())))
                moves.push({row: row+dir, col: col+dc});
            }
          }
          break;
        case 'N':
          const knightMoves = [
            {r: -2, c: -1}, {r: -2, c: 1},
            {r: -1, c: -2}, {r: -1, c: 2},
            {r: 1, c: -2}, {r: 1, c: 2},
            {r: 2, c: -1}, {r: 2, c: 1}
          ];
          knightMoves.forEach(m=>{
            const newRow = row+m.r, newCol = col+m.c;
            if(inBounds(newRow,newCol)){
              const target = boardState[newRow][newCol];
              if(!target || (isWhite && target===target.toLowerCase()) || (!isWhite && target===target.toUpperCase()))
                moves.push({row:newRow, col:newCol});
            }
          });
          break;
        case 'B':
          moves.push(...generateSlidingMovesFromBoard(row, col, piece, [[-1,-1],[-1,1],[1,-1],[1,1]], boardState));
          break;
        case 'R':
          moves.push(...generateSlidingMovesFromBoard(row, col, piece, [[-1,0],[1,0],[0,-1],[0,1]], boardState));
          break;
        case 'Q':
          moves.push(...generateSlidingMovesFromBoard(row, col, piece, [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]], boardState));
          break;
        case 'K':
          for(let dr=-1; dr<=1; dr++){
            for(let dc=-1; dc<=1; dc++){
              if(dr===0 && dc===0) continue;
              const newRow = row+dr, newCol = col+dc;
              if(inBounds(newRow,newCol)){
                const target = boardState[newRow][newCol];
                if(!target || (isWhite && target===target.toLowerCase()) || (!isWhite && target===target.toUpperCase()))
                  moves.push({row:newRow, col:newCol});
              }
            }
          }
          break;
      }
      return moves;
    }
    function generateSlidingMovesFromBoard(row, col, piece, directions, boardState) {
      const moves = [];
      directions.forEach(dir=>{
        let newRow = row+dir[0], newCol = col+dir[1];
        while(inBounds(newRow,newCol)){
          const target = boardState[newRow][newCol];
          if(!target){
            moves.push({row:newRow, col:newCol});
          } else {
            if(isOpponentPiece(piece, target))
              moves.push({row:newRow, col:newCol});
            break;
          }
          newRow += dir[0];
          newCol += dir[1];
        }
      });
      return moves;
    }

    /***********************************
     * MOVE HANDLING, SPECIAL RULES & UNDO
     ***********************************/
    function handleSquareClick(event) {
      const square = event.currentTarget;
      const row = parseInt(square.dataset.row);
      const col = parseInt(square.dataset.col);
      const piece = board[row][col];
      if (currentTurn !== 'white') return;
      if (selectedSquare) {
        if (piece && piece === piece.toUpperCase()) {
          clearHighlights();
          selectedSquare = {row, col};
          highlightSquare(square);
          if (showHints) highlightLegalMoves(row, col);
          return;
        }
        const legalMoves = getLegalMoves(selectedSquare.row, selectedSquare.col);
        const move = legalMoves.find(m => m.row === row && m.col === col);
        if (move) {
          makeMove(selectedSquare, move);
          clearHighlights();
          selectedSquare = null;
          if (currentTurn !== 'none') {
            currentTurn = 'black';
            statusElement.textContent = "Turn: AI";
            setTimeout(aiMove, 600);
          }
        } else {
          clearHighlights();
          selectedSquare = null;
        }
      } else {
        if (piece && piece === piece.toUpperCase()) {
          selectedSquare = {row, col};
          highlightSquare(square);
          if (showHints) highlightLegalMoves(row, col);
        }
      }
    }

    function highlightSquare(squareElement) {
      squareElement.classList.add('selected');
    }
    function highlightLegalMoves(row, col) {
      const moves = getLegalMoves(row, col);
      moves.forEach(move => {
        const sq = document.querySelector(`.square[data-row='${move.row}'][data-col='${move.col}']`);
        if (sq) sq.classList.add('highlight');
      });
    }
    function clearHighlights() {
      document.querySelectorAll('.square').forEach(sq => {
        sq.classList.remove('selected', 'highlight');
      });
    }

    function makeMove(from, move) {
      const movingPiece = board[from.row][from.col];
      const captured = board[move.row][move.col] || null;
      moveHistory.push({
        from: { ...from },
        to: { row: move.row, col: move.col },
        movingPiece,
        captured,
        enPassantTarget: enPassantTarget ? { ...enPassantTarget } : null,
        castlingRights: { ...castlingRights },
        castling: move.castling || null
      });
      enPassantTarget = null;
      if (move.enPassantCapture) {
        const capRow = (movingPiece === movingPiece.toUpperCase()) ? move.row+1 : move.row-1;
        moveHistory[moveHistory.length-1].captured = board[capRow][move.col];
        board[capRow][move.col] = "";
      }
      board[move.row][move.col] = movingPiece;
      board[from.row][from.col] = "";
      if (move.castling) {
        if (move.castling === 'king') {
          board[move.row][move.col-1] = board[move.row][7];
          board[move.row][7] = "";
        } else if (move.castling === 'queen') {
          board[move.row][move.col+1] = board[move.row][0];
          board[move.row][0] = "";
        }
      }
      updateCastlingRights(from, move);
      if (move.promotion) {
        promptPromotion(move.row, move.col, movingPiece);
      }
      if (movingPiece.toUpperCase() === 'P' && Math.abs(from.row - move.row) === 2) {
        enPassantTarget = { row: (from.row + move.row) / 2, col: from.col };
      }
      initBoard();
      const newSq = document.querySelector(`.square[data-row='${move.row}'][data-col='${move.col}']`);
      if(newSq && newSq.firstChild)
        newSq.firstChild.classList.add('move-animation');
      if (!moveSoundMuted) moveSound.play();
      if (captured) {
        if (movingPiece === movingPiece.toUpperCase()) {
          capturedByPlayer.push(captured);
          updateCapturedDisplay(capturedByPlayerEl, capturedByPlayer);
        } else {
          capturedByAI.push(captured);
          updateCapturedDisplay(capturedByAIEl, capturedByAI);
        }
      }
      detectGameState();
    }

    function updateCastlingRights(from, move) {
      const piece = board[move.row][move.col];
      if (piece.toUpperCase() === 'K') {
        if (piece === 'K') { castlingRights.whiteKing = false; castlingRights.whiteQueen = false; }
        else { castlingRights.blackKing = false; castlingRights.blackQueen = false; }
      }
      if (piece.toUpperCase() === 'R') {
        if (from.row===7 && from.col===0) castlingRights.whiteQueen = false;
        if (from.row===7 && from.col===7) castlingRights.whiteKing = false;
        if (from.row===0 && from.col===0) castlingRights.blackQueen = false;
        if (from.row===0 && from.col===7) castlingRights.blackKing = false;
      }
      if (move.captured) {
        if (move.row===7 && move.col===0) castlingRights.whiteQueen = false;
        if (move.row===7 && move.col===7) castlingRights.whiteKing = false;
        if (move.row===0 && move.col===0) castlingRights.blackQueen = false;
        if (move.row===0 && move.col===7) castlingRights.blackKing = false;
      }
    }

    function promptPromotion(row, col, pawn) {
      openModal(`
        <h2>Pawn Promotion!</h2>
        <p>Choose a piece:</p>
        <button class="promote" data-piece="Q">Queen</button>
        <button class="promote" data-piece="R">Rook</button>
        <button class="promote" data-piece="B">Bishop</button>
        <button class="promote" data-piece="N">Knight</button>
      `);
      document.querySelectorAll('.promote').forEach(btn => {
        btn.addEventListener('click', () => {
          const choice = btn.dataset.piece;
          board[row][col] = (pawn === pawn.toUpperCase()) ? choice : choice.toLowerCase();
          closeModalFunc();
          initBoard();
        });
      });
    }

    function undoMove() {
      if (moveHistory.length === 0) return;
      const lastMove = moveHistory.pop();
      board[lastMove.from.row][lastMove.from.col] = lastMove.movingPiece;
      board[lastMove.to.row][lastMove.to.col] = lastMove.captured || "";
      if (lastMove.captured && lastMove.capturedEnPassant) {
        const capRow = (lastMove.movingPiece === lastMove.movingPiece.toUpperCase()) ? lastMove.to.row+1 : lastMove.to.row-1;
        board[capRow][lastMove.to.col] = lastMove.captured;
      }
      if (lastMove.castling) {
        if (lastMove.castling==='king') {
          board[lastMove.to.row][7] = board[lastMove.to.row][lastMove.to.col-1];
          board[lastMove.to.row][lastMove.to.col-1] = "";
        } else if (lastMove.castling==='queen') {
          board[lastMove.to.row][0] = board[lastMove.to.row][lastMove.to.col+1];
          board[lastMove.to.row][lastMove.to.col+1] = "";
        }
      }
      enPassantTarget = lastMove.enPassantTarget;
      castlingRights = lastMove.castlingRights;
      currentTurn = 'white';
      statusElement.textContent = "Turn: White";
      initBoard();
    }

    /***********************************
     * EVALUATION FUNCTION & SMART HINTS
     ***********************************/
    function evaluateBoard(boardState) {
      const values = { 'P': 1, 'N': 3, 'B': 3, 'R': 5, 'Q': 9, 'K': 1000 };
      let score = 0;
      for (let i=0; i<8; i++){
        for (let j=0; j<8; j++){
          const piece = boardState[i][j];
          if(piece) {
            const upper = piece.toUpperCase();
            let pieceValue = values[upper] || 0;
            if(piece === piece.toUpperCase()) score += pieceValue;
            else score -= pieceValue;
          }
        }
      }
      return score;
    }

    function getBestHintMove() {
      let bestScore = -Infinity;
      let bestMove = null;
      let bestFrom = null;
      for (let i=0; i<8; i++){
        for (let j=0; j<8; j++){
          const piece = board[i][j];
          if(piece && piece === piece.toUpperCase()){
            const legalMoves = getLegalMoves(i, j);
            legalMoves.forEach(move => {
              let boardCopy = board.map(row => row.slice());
              boardCopy[move.row][move.col] = piece;
              boardCopy[i][j] = "";
              let score = evaluateBoard(boardCopy);
              if(score > bestScore){
                bestScore = score;
                bestMove = move;
                bestFrom = { row: i, col: j };
              }
            });
          }
        }
      }
      return { from: bestFrom, move: bestMove };
    }

    function giveHint() {
      clearHighlights();
      const hint = getBestHintMove();
      if (hint.from && hint.move) {
        const fromSq = document.querySelector(`.square[data-row='${hint.from.row}'][data-col='${hint.from.col}']`);
        const toSq = document.querySelector(`.square[data-row='${hint.move.row}'][data-col='${hint.move.col}']`);
        if (fromSq) fromSq.classList.add('selected');
        if (toSq) toSq.classList.add('highlight');
        openPopup(`Hint: Try moving from ${String.fromCharCode(65 + hint.from.col)}${8 - hint.from.row} to ${String.fromCharCode(65 + hint.move.col)}${8 - hint.move.row}`);
        selectedSquare = { row: hint.from.row, col: hint.from.col };
      } else {
        openPopup("No good hint found!");
      }
    }

    /***********************************
     * GAME STATE CHECKS: CHECK, CHECKMATE, STALEMATE, DRAW
     ***********************************/
    function detectGameState() {
      let popupMsg = "";
      const legalMoves = getAllLegalMoves(currentTurn);
      if (legalMoves.length === 0) {
        if (isKingInCheck(currentTurn)) {
          popupMsg = (currentTurn==='white') ? "Checkmate! You lose." : "Checkmate! You win.";
          currentTurn = 'none';
        } else {
          popupMsg = "Stalemate! Draw.";
          currentTurn = 'none';
        }
      } else {
        if (isKingInCheck(currentTurn)) {
          popupMsg = "Check!";
        }
      }
      if (popupMsg) openPopup(popupMsg);
      if (currentTurn !== 'none' && !popupMsg) {
        statusElement.textContent = (currentTurn==='white') ? "Turn: White" : "Turn: AI";
      } else {
        statusElement.textContent = popupMsg;
      }
    }

    function isKingInCheck(color) {
      const kingPos = findKing(color);
      if (!kingPos) return true;
      const opponent = (color==='white') ? 'black' : 'white';
      return squareAttacked(kingPos.row, kingPos.col, opponent);
    }

    function findKing(color) {
      const king = (color==='white') ? 'K' : 'k';
      for (let i=0; i<8; i++){
        for (let j=0; j<8; j++){
          if (board[i][j] === king)
            return {row: i, col: j};
        }
      }
      return null;
    }

    function getAllLegalMoves(color) {
      const moves = [];
      for (let i=0; i<8; i++){
        for (let j=0; j<8; j++){
          const p = board[i][j];
          if (p && ((color==='white' && p===p.toUpperCase()) || (color==='black' && p===p.toLowerCase()))) {
            const pieceMoves = getLegalMoves(i, j);
            if (pieceMoves.length > 0)
              moves.push(...pieceMoves);
          }
        }
      }
      return moves;
    }

    /***********************************
     * AI MOVE (Simplified Random Move)
     ***********************************/
    function aiMove() {
      const moves = [];
      for (let i=0; i<8; i++){
        for (let j=0; j<8; j++){
          const p = board[i][j];
          if (p && p===p.toLowerCase()) {
            const legal = getLegalMoves(i,j);
            legal.forEach(m => {
              moves.push({from: {row: i, col: j}, move: m});
            });
          }
        }
      }
      if (moves.length === 0) {
        openPopup("Stalemate!");
        currentTurn = 'none';
        return;
      }
      const chosen = moves[Math.floor(Math.random()*moves.length)];
      makeMove(chosen.from, chosen.move);
      currentTurn = 'white';
      statusElement.textContent = "Turn: White";
    }

    /***********************************
     * MODAL POPUPS (for messages, settings, promotion)
     ***********************************/
    function openModal(content) {
      modalBody.innerHTML = content;
      modal.style.display = 'flex';
    }
    function closeModalFunc() {
      modal.style.display = 'none';
    }
    closeModal.onclick = closeModalFunc;
    window.onclick = function(event) {
      if (event.target === modal) closeModalFunc();
    }
    function openPopup(message) {
      openModal(`<h2>${message}</h2><button id="closePopup">OK</button>`);
      document.getElementById('closePopup').addEventListener('click', closeModalFunc);
    }
    function openSettings() {
      openModal(`
        <h2>Settings</h2>
        <label>Difficulty:
          <select id="difficultySelect">
            <option value="easy" ${difficulty==="easy"?"selected":""}>Easy</option>
            <option value="med" ${difficulty==="med"?"selected":""}>Medium</option>
            <option value="high" ${difficulty==="high"?"selected":""}>High</option>
            <option value="prof" ${difficulty==="prof"?"selected":""}>Pro</option>
            <option value="legend" ${difficulty==="legend"?"selected":""}>Legend</option>
          </select>
        </label>
        <label>Show Hints:
          <input type="checkbox" id="hintToggle" ${showHints?"checked":""}>
        </label>
        <label>Mute Background Music:
          <input type="checkbox" id="bgMusicToggle" ${bgMusicMuted?"checked":""}>
        </label>
        <label>Mute Sound Effects:
          <input type="checkbox" id="moveSoundToggle" ${moveSoundMuted?"checked":""}>
        </label>
        <button id="saveSettings">Save Settings</button>
      `);
      document.getElementById('saveSettings').addEventListener('click', () => {
        difficulty = document.getElementById('difficultySelect').value;
        showHints = document.getElementById('hintToggle').checked;
        bgMusicMuted = document.getElementById('bgMusicToggle').checked;
        moveSoundMuted = document.getElementById('moveSoundToggle').checked;
        if (bgMusicMuted) {
          bgMusic.pause();
        } else {
          bgMusic.play();
        }
        closeModalFunc();
      });
    }
    function openHowToPlay() {
      openModal(`
        <h2>How to Play</h2>
        <p>You play as White against an AI opponent.</p>
        <p>All standard chess rules are implemented:</p>
        <ul style="text-align: left;">
          <li>Pawns move forward (and capture diagonally). They can move two squares from their start and promote upon reaching the end.</li>
          <li>Castling is allowed if conditions are met.</li>
          <li>En passant captures are available.</li>
          <li>The game detects check, checkmate, and stalemate.</li>
          <li>You can undo your last move using the Undo button.</li>
          <li>Board coordinates are displayed on the borders.</li>
          <li>Background music and move sound effects can be toggled in settings.</li>
        </ul>
        <p>Good luck!</p>
      `);
    }

    /***********************************
     * UPDATE CAPTURED PIECES DISPLAY
     ***********************************/
    function updateCapturedDisplay(container, pieces) {
      container.innerHTML = `<h3>${container.id==="capturedByPlayer"?"Captured by You":"Captured by AI"}</h3>`;
      pieces.forEach(p => {
        const pieceDiv = document.createElement('div');
        pieceDiv.classList.add('piece');
        const img = document.createElement('img');
        img.src = pieceImages[p];
        img.alt = p;
        pieceDiv.appendChild(img);
        container.appendChild(pieceDiv);
      });
    }

    /***********************************
     * SMART HINT FUNCTIONALITY
     ***********************************/
    function getBestHintMove() {
      let bestScore = -Infinity;
      let bestMove = null;
      let bestFrom = null;
      for (let i=0; i<8; i++){
        for (let j=0; j<8; j++){
          const piece = board[i][j];
          if(piece && piece === piece.toUpperCase()){
            const legalMoves = getLegalMoves(i, j);
            legalMoves.forEach(move => {
              let boardCopy = board.map(row => row.slice());
              boardCopy[move.row][move.col] = piece;
              boardCopy[i][j] = "";
              let score = evaluateBoard(boardCopy);
              if(score > bestScore){
                bestScore = score;
                bestMove = move;
                bestFrom = { row: i, col: j };
              }
            });
          }
        }
      }
      return { from: bestFrom, move: bestMove };
    }

    function giveHint() {
      clearHighlights();
      const hint = getBestHintMove();
      if (hint.from && hint.move) {
        const fromSq = document.querySelector(`.square[data-row='${hint.from.row}'][data-col='${hint.from.col}']`);
        const toSq = document.querySelector(`.square[data-row='${hint.move.row}'][data-col='${hint.move.col}']`);
        if (fromSq) fromSq.classList.add('selected');
        if (toSq) toSq.classList.add('highlight');
        openPopup(`Hint: Try moving from ${String.fromCharCode(65 + hint.from.col)}${8 - hint.from.row} to ${String.fromCharCode(65 + hint.move.col)}${8 - hint.move.row}`);
        selectedSquare = { row: hint.from.row, col: hint.from.col };
      } else {
        openPopup("No good hint found!");
      }
    }

    /***********************************
     * EVENT LISTENERS
     ***********************************/
    document.getElementById('playNow').addEventListener('click', () => {
      mainMenu.style.display = 'none';
      gameContainer.style.display = 'flex';
      initGame();
    });
    document.getElementById('backToMenu').addEventListener('click', () => {
      gameContainer.style.display = 'none';
      mainMenu.style.display = 'block';
      bgMusic.pause();
    });
    document.getElementById('settingsBtn').addEventListener('click', openSettings);
    document.getElementById('howToPlayBtn').addEventListener('click', openHowToPlay);
    hintBtn.addEventListener('click', giveHint);
    undoBtn.addEventListener('click', undoMove);
  </script>
</body>
</html>
